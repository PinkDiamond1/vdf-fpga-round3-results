# timing constraints for synthesis step

#---------------------------------------------------------------------------------------------------
# find the MMCM cell name

set MMCM_cell [get_cells -hier -regexp {.*/MMCME4_inst_}]

#---------------------------------------------------------------------------------------------------
# fix names for auto-derived clocks generated by MMCM
# only specify clocks that have loads

create_generated_clock -name  modsqr_clk_phase_00 [get_pins -of_object $MMCM_cell -filter {REF_PIN_NAME==CLKOUT0}]
create_generated_clock -name  modsqr_clk_phase_08 [get_pins -of_object $MMCM_cell -filter {REF_PIN_NAME==CLKOUT0B}]
create_generated_clock -name  modsqr_clk_phase_05 [get_pins -of_object $MMCM_cell -filter {REF_PIN_NAME==CLKOUT1}]
create_generated_clock -name  modsqr_clk_phase_10 [get_pins -of_object $MMCM_cell -filter {REF_PIN_NAME==CLKOUT2B}]

#---------------------------------------------------------------------------------------------------
# fix clock phase relationships
# rest of paths are correct with default 1 cycle

set_multicycle_path -setup 0 -from [get_clocks modsqr_clk_phase_00] -to [get_clocks modsqr_clk_phase_05]

#---------------------------------------------------------------------------------------------------
# set_max_delay on clock domain crossing (CDC) paths

# because modsqr clocks are asynchronous to the kernel (mostly, sorta, let's pretend they are)
# the right thing to do is this:
#   set_clock_groups -name modsqr_clk -asynchronous -group [get_clocks modsqr_clk_phase*]
# but that incorrectly overrides these set_max_delay we use for CDC constraints

# first, get the periods

set KERNEL_CLOCK_PERIOD [get_property PERIOD [get_clocks clk_extra_b0]]
set MODSQR_CLOCK_PERIOD [get_property PERIOD [get_clocks modsqr_clk_phase_00]]

# max delay for control signals that get synchronized is a bit less than one clock period of capture clock

set MAX_DELAY_CONTROL_TO_KERNEL [expr 0.9 * ${KERNEL_CLOCK_PERIOD}]
set MAX_DELAY_CONTROL_TO_MODSQR [expr 0.9 * ${MODSQR_CLOCK_PERIOD}]

# round off values to nearest picosecond

set MAX_DELAY_CONTROL_TO_KERNEL [expr round(1000 * ${MAX_DELAY_CONTROL_TO_KERNEL}) / 1000.0]
set MAX_DELAY_CONTROL_TO_MODSQR [expr round(1000 * ${MAX_DELAY_CONTROL_TO_MODSQR}) / 1000.0]

# max delay for datapath is twice as long (because there are no sync flops)

set MAX_DELAY_DATAPATH_TO_KERNEL [expr 2 * ${MAX_DELAY_CONTROL_TO_KERNEL}]
set MAX_DELAY_DATAPATH_TO_MODSQR [expr 2 * ${MAX_DELAY_CONTROL_TO_MODSQR}]

# default max delay covers the datapath : sq_in, sq_out

set_max_delay \
    -datapath_only \
    -from [get_clocks clk_extra_b0] \
    -to   [get_clocks modsqr_clk_phase_00] \
    ${MAX_DELAY_DATAPATH_TO_MODSQR}

set_max_delay \
    -datapath_only \
    -from [get_clocks modsqr_clk_phase_00] \
    -to   [get_clocks clk_extra_b0] \
    ${MAX_DELAY_DATAPATH_TO_KERNEL}

# override these defaults for specific control signals

# modsqr_reset sync flop
set_max_delay \
    -datapath_only \
    -from [get_clocks clk_extra_b0] \
    -to [get_pins \
	     -of_object [get_cells -hier -filter {IS_SEQUENTIAL == true && NAME =~ *modsqr*/modsqr_reset_sync1_reg* }] \
	     -filter {DIRECTION == IN && IS_CLOCK == false}] \
    ${MAX_DELAY_CONTROL_TO_MODSQR}

# modsqr_start sync flop
set_max_delay \
    -datapath_only \
    -from [get_clocks clk_extra_b0] \
    -to [get_pins \
	     -of_object [get_cells -hier -filter {IS_SEQUENTIAL == true && NAME =~ *modsqr*/modsqr_start_sync1_reg* }] \
	     -filter {DIRECTION == IN && IS_CLOCK == false}] \
    ${MAX_DELAY_CONTROL_TO_MODSQR}

# valid sync flop
set_max_delay \
    -datapath_only \
    -from [get_clocks modsqr_clk_phase_00] \
    -to [get_pins \
	     -of_object [get_cells -hier -filter {IS_SEQUENTIAL == true && NAME =~ *modsqr*/valid_sync1_reg* }] \
	     -filter {DIRECTION == IN && IS_CLOCK == false}] \
    ${MAX_DELAY_CONTROL_TO_KERNEL}

#---------------------------------------------------------------------------------------------------
# force bypass signal to *not* bypass
# this greatly reduces the number of timing paths

set_case_analysis 0 \
    [get_pins \
	 -of_object [get_cells -hier -filter {IS_SEQUENTIAL == true && NAME =~ *modsqr*/bypass_reg* }] \
	 -filter {DIRECTION == OUT}]
